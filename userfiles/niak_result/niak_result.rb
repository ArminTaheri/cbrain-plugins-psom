
#
# CBRAIN Project
#
# Copyright (C) 2008-2012
# The Royal Institution for the Advancement of Learning
# McGill University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# Model for Niak results.
class NiakResult < FileCollection

  Revision_info=CbrainFileRevision[__FILE__] #:nodoc:

  has_viewer :name => "Niak Viewer",  :partial => :niak_viewer

  has_content :html_file

  def self.pretty_type #:nodoc:
    "Niak result"
  end

  def self.file_name_pattern #:nodoc:
    /\.niak$/i
  end

 ##################################################################################################
  # This method returns the content of an HTML file modified so that it can be
  # displayed in the content section of the userfile page.  It
  # basically removes some HTML tags (html, body, object, head, title)
  # and tweaks the URLs found in <a> and <img> tags.  It is quite
  # specific to the HTML pages generated by FSL melodic. A more
  # generic implementation would require a complete parsing of the
  # HTML code.  It is recursively called for each iframe contained in
  # the page.
  # Parameters:
  #  * file_path: the path of the HTML file whose content will be read, modified and returned.
  #  * dir_name: the directory name of the HTML file in the melodic file collection.
  ##################################################################################################


  def modified_file_content file_path,dir_name
    return nil unless File.exists?(file_path)

    file_contents = File.open(file_path).read

    lines = Array.new
    # The file is processed line by line to speed up substitutions.
    is_motion_directory = /report\/motion\/.*$/.match file_path.to_s
    file_contents.each_line do |line|
      line_dir_name = dir_name
      new_line = line
      if is_motion_directory and !(/\.\.\//.match new_line)
        line_dir_name += "motion/"
      else
        new_line = new_line.gsub /\.\.\//, ''
      end
      new_line = new_line.gsub /(src|href)\s*=\s*"(.*)"/, "\\1=\"#{line_dir_name}\\2\""
      if /url\(.*\);.*$/.match new_line
        new_line = new_line.gsub /url\(('|")?([^'"+]*)(.*[^'"]*)('|")?\)/, "url\(\\1#{line_dir_name}\\2\\3\\4\)"
      else
        new_line = new_line.gsub /url\((.*)\)/, "url\(#{line_dir_name}\\1\)"
      end
      lines << new_line
    end
    return lines.join
  end
  def remove_source_maps file_path
    return nil unless File.exists?(file_path)

    file_contents = File.open(file_path).read

    lines = Array.new
    file_contents.each_line do |line|
      lines << line unless line =~ /\/\/# sourceMappingURL/
    end
    return lines.join
  end
  # Content loader
  def html_file(path_string)
    return nil unless self.list_files.find { |f| f.name == path_string }

    path = self.cache_full_path.parent + path_string

    return nil unless File.exist?(path) and File.readable?(path) and !(File.directory?(path) || File.symlink?(path) )

    if path.extname == '.html'
      begin
        File.open("/tmp/file.html", 'w') { |file| file.write(modified_file_content(path, "/userfiles/#{self.id}/content?content_loader=html_file&arguments=#{self.name}/report/")) }
      rescue => ex
        File.open("/tmp/file.html", 'w') { |file| file.write("#{path}"+"\n"+ex.message) }
      end
      return "/tmp/file.html"
    end

    if path.extname == '.js'
      begin
        File.open("/tmp/file.js", 'w') { |file| file.write(remove_source_maps(path)) }
      rescue => ex
        File.open("/tmp/file.js", 'w') { |file| file.write("#{path}"+"\n"+ex.message) }
      end
      return "/tmp/file.js"
    end

    FileUtils.cp path, "/tmp"
    "/tmp/#{path.basename}"
  end

end
